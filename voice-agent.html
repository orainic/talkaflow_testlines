<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title id="pageTitle">TalkaFlow Voice AI</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="icon" type="image/png" href="/talkaFlow_logo_only.png">
  <style>
    /* Dark mode transitions */
    body, .dark-mode-bg, .dark-mode-card, .dark-mode-header {
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    /* Dark mode styles */
    body.dark-mode {
      background: linear-gradient(to bottom right, #1a1a2e, #16213e) !important;
    }

    body.dark-mode .dark-mode-header {
      background-color: #1e293b;
      border-bottom-color: #334155;
    }

    body.dark-mode .dark-mode-card {
      background-color: #1e293b;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
    }

    body.dark-mode .dark-mode-text {
      color: #e2e8f0;
    }

    body.dark-mode .dark-mode-text-secondary {
      color: #94a3b8;
    }

    body.dark-mode .dark-mode-bg-secondary {
      background-color: #0f172a;
    }

    body.dark-mode .dark-mode-border {
      border-color: #334155;
    }

    body.dark-mode .dark-mode-message-agent {
      background-color: #2d3748;
      border-left-color: #4a5568;
    }
  </style>
  <!-- Load SDK from multiple sources -->
  <script>
    window.loadSDK = async function() {
      const sources = [
        'https://cdn.skypack.dev/ultravox-client@0.4.1',
        'https://unpkg.com/ultravox-client@0.4.1?module',
        'https://esm.run/ultravox-client@0.4.1',
        'https://cdn.jsdelivr.net/npm/ultravox-client@0.4.1/+esm'
      ];

      for (const src of sources) {
        try {
          const module = await import(src);
          if (module.UltravoxSession) {
            window.UltravoxSession = module.UltravoxSession;
            console.log('✅ SDK loaded from:', src);
            return true;
          }
        } catch (e) {
          console.log('❌ Failed:', src, e.message);
        }
      }
      return false;
    };
  </script>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen">
  <!-- Header with Logo -->
  <div class="bg-white shadow-sm border-b dark-mode-header">
    <div class="max-w-4xl mx-auto px-4 py-4">
      <div class="flex items-center justify-between">
        <div class="flex items-center space-x-3">
          <a href="https://www.talkaflow.com">
            <img src="/talkaFlow_logo_only.png" alt="TalkaFlow" class="w-10 h-10 hover:opacity-80 transition-opacity cursor-pointer" />
          </a>
          <div>
            <h1 id="agentName" class="text-xl font-bold text-gray-900 dark-mode-text">TalkaFlow Voice AI</h1>
            <p id="agentTitle" class="text-sm text-gray-600 dark-mode-text-secondary">AI Voice Assistant</p>
          </div>
        </div>
        <a href="https://www.talkaflow.com"
           class="w-9 h-9 rounded-full flex items-center justify-center transition-all hover:scale-110"
           style="background-color: rgba(17, 109, 255, 0.1);"
           onmouseover="this.style.backgroundColor='rgba(17, 109, 255, 0.2)'"
           onmouseout="this.style.backgroundColor='rgba(17, 109, 255, 0.1)'"
           title="Return to TalkaFlow Home">
          <i class="fas fa-home" style="color: #116dff;"></i>
        </a>
      </div>
    </div>
  </div>

  <div class="max-w-4xl mx-auto px-4 py-8">
    <!-- Main Call Interface -->
    <div class="bg-white rounded-xl shadow-lg p-8 mb-6 dark-mode-card">
      <div class="text-center mb-8">
        <div class="inline-flex items-center justify-center w-16 h-16 rounded-full mb-4" style="background-color: #116dff;">
          <i id="agentIcon" class="fas fa-microphone text-white text-2xl"></i>
        </div>
        <h2 id="agentDescription" class="text-2xl font-bold text-gray-900 dark-mode-text mb-4">AI Voice Assistant</h2>

        <!-- Status Indicator -->
        <div id="connectionStatus" class="flex items-center justify-center space-x-3 mb-6 p-4 rounded-lg" style="background-color: rgba(17, 109, 255, 0.05);">
          <div id="statusDot" class="w-4 h-4 rounded-full bg-gray-400"></div>
          <span id="statusText" class="text-lg font-semibold text-gray-700 dark-mode-text">Disconnected</span>
        </div>

        <!-- Call Button -->
        <div class="space-y-4">
          <button id="callButton"
                  class="disabled:bg-gray-400 text-white px-12 py-6 rounded-xl font-bold text-xl transition-all transform hover:scale-105 shadow-lg disabled:cursor-not-allowed disabled:transform-none"
                  style="background-color: #008250;"
                  onmouseover="if(!this.disabled) this.style.backgroundColor='#006b43'"
                  onmouseout="if(!this.disabled && !this.dataset.connected) this.style.backgroundColor='#008250'; else if(!this.disabled && this.dataset.connected) this.style.backgroundColor='#df3131'">
            <i id="callIcon" class="fas fa-phone mr-3"></i>
            <span id="callText">Start Voice Call</span>
          </button>

          <p class="text-sm text-gray-600">
            Click to connect with the AI assistant
          </p>
        </div>
      </div>

      <!-- What You Can Ask -->
      <div id="suggestionsContainer" class="rounded-lg p-6 mb-6" style="background-color: rgba(17, 109, 255, 0.08);">
        <h3 class="font-semibold mb-3" style="color: #116dff;">
          <i class="fas fa-question-circle mr-2"></i>
          What you can ask:
        </h3>
        <div id="suggestionsList" class="grid grid-cols-1 md:grid-cols-2 gap-3 text-sm" style="color: #116dff;">
          <!-- Dynamically populated -->
        </div>
      </div>

      <!-- Conversation Area -->
      <div class="bg-gray-50 rounded-lg p-6 dark-mode-bg-secondary">
        <h3 class="font-semibold text-gray-900 dark-mode-text mb-4 flex items-center">
          <i class="fas fa-comments mr-2"></i>
          Conversation
        </h3>
        <div id="conversation" class="space-y-3 max-h-96 overflow-y-auto">
          <div class="text-center text-gray-500 dark-mode-text-secondary py-8">
            <i class="fas fa-microphone text-4xl mb-3 opacity-30"></i>
            <p>Start a call to begin speaking with the AI assistant</p>
          </div>
        </div>
      </div>
    </div>

    <!-- Dark Mode Toggle Button -->
    <div class="fixed bottom-4 left-4 z-40">
      <button id="darkModeToggle" class="text-white w-12 h-12 rounded-full shadow-lg flex items-center justify-center transition-all" style="background-color: #116dff;" onmouseover="this.style.backgroundColor='#0d5cd6'" onmouseout="this.style.backgroundColor='#116dff'" title="Toggle Dark Mode">
        <i id="darkModeIcon" class="fas fa-moon text-lg"></i>
      </button>
    </div>

    <!-- Debug Panel - Small Icon with Preview -->
    <div class="fixed bottom-4 right-4 z-40">
      <!-- Compact Preview (collapsed state) -->
      <div id="debugPreview" class="bg-white rounded-lg shadow-xl mb-2 p-3 max-w-xs hidden dark-mode-card">
        <div class="flex items-center justify-between mb-2">
          <h4 class="text-xs font-semibold text-gray-700 dark-mode-text">Recent Logs</h4>
          <button id="debugExpandBtn" class="text-xs" style="color: #116dff;" onmouseover="this.style.color='#0d5cd6'" onmouseout="this.style.color='#116dff'">
            <i class="fas fa-expand-alt"></i>
          </button>
        </div>
        <div id="debugPreviewContent" class="text-xs font-mono text-gray-600 max-h-32 overflow-y-auto space-y-1">
          <p>Loading...</p>
        </div>
      </div>

      <!-- Toggle Button -->
      <button id="debugToggle" class="text-white w-12 h-12 rounded-full shadow-lg flex items-center justify-center transition-all relative" style="background-color: #116dff;" onmouseover="this.style.backgroundColor='#0d5cd6'" onmouseout="this.style.backgroundColor='#116dff'" title="Debug Logs">
        <i class="fas fa-bug text-lg"></i>
        <span id="debugBadge" class="absolute -top-1 -right-1 text-white text-xs w-5 h-5 rounded-full hidden items-center justify-center font-bold" style="background-color: #df3131;">0</span>
      </button>
    </div>

    <!-- Debug Panel Modal (Hidden by default) -->
    <div id="debugModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
      <div class="bg-white rounded-lg shadow-xl max-w-2xl w-full mx-4 max-h-96 flex flex-col dark-mode-card">
        <div class="flex items-center justify-between p-4 border-b dark-mode-border">
          <h3 class="font-medium text-gray-900 dark-mode-text flex items-center">
            <i class="fas fa-cog mr-2"></i>
            Technical Information
          </h3>
          <div class="flex items-center space-x-2">
            <button id="downloadLogsBtn" class="text-xs px-3 py-1 rounded text-white transition-all" style="background-color: #116dff;" onmouseover="this.style.backgroundColor='#0d5cd6'" onmouseout="this.style.backgroundColor='#116dff'" title="Download all logs as file">
              <i class="fas fa-download mr-1"></i>
              Download Logs
            </button>
            <button id="clearLogsBtn" class="text-xs px-3 py-1 rounded text-white transition-all" style="background-color: #df3131;" onmouseover="this.style.backgroundColor='#b92828'" onmouseout="this.style.backgroundColor='#df3131'" title="Clear all saved logs">
              <i class="fas fa-trash mr-1"></i>
              Clear Logs
            </button>
            <button id="debugClose" class="text-gray-400 hover:text-gray-600">
              <i class="fas fa-times"></i>
            </button>
          </div>
        </div>
        <div id="debugInfo" class="p-4 text-xs font-mono text-gray-600 overflow-y-auto flex-1">
          <p>Loading system...</p>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Load agent configuration
    let agentConfig = null;
    let agentsData = null;

    // Parse URL to get agent type - check both path and query param
    function getAgentType() {
      // First check query parameter
      const urlParams = new URLSearchParams(window.location.search);
      const queryAgent = urlParams.get('agent');
      if (queryAgent) return queryAgent;

      // Then check path (e.g., /hotel, /clinic)
      const path = window.location.pathname;
      const pathMatch = path.match(/\/(hotel|clinic|aftersales|restaurant|hairstudio|hepa|dental)/);
      if (pathMatch) return pathMatch[1];

      // Default to hotel
      return 'hotel';
    }

    const agentType = getAgentType();

    // Load agents config
    fetch('/agents-config.json')
      .then(res => res.json())
      .then(data => {
        agentsData = data;
        agentConfig = data[agentType];

        if (!agentConfig) {
          console.error('Unknown agent type:', agentType);
          agentConfig = data.hotel; // Fallback to hotel
        }

        // Update page with agent info
        updateAgentInfo();

        // Enable button if SDK is already loaded
        updateCallButton();
      })
      .catch(err => {
        console.error('Failed to load agent config:', err);
      });

    function updateAgentInfo() {
      if (!agentConfig) return;

      // Update page title and meta
      document.title = `${agentConfig.name} - TalkaFlow Voice AI`;
      document.getElementById('pageTitle').textContent = `${agentConfig.name} - TalkaFlow`;
      document.getElementById('agentName').textContent = agentConfig.name;
      document.getElementById('agentTitle').textContent = agentConfig.title;
      document.getElementById('agentDescription').textContent = agentConfig.description;
      document.getElementById('agentIcon').className = `fas ${agentConfig.icon} text-white text-2xl`;

      // Update suggestions
      const suggestionsList = document.getElementById('suggestionsList');
      suggestionsList.innerHTML = '';
      agentConfig.suggestions.forEach(suggestion => {
        const div = document.createElement('div');
        div.className = 'flex items-start';
        div.innerHTML = `
          <i class="fas fa-comment-dots mr-2 mt-1 flex-shrink-0" style="color: #116dff;"></i>
          <span>"${suggestion}"</span>
        `;
        suggestionsList.appendChild(div);
      });

      log(`Agent loaded: ${agentConfig.name} (${agentConfig.id})`);
    }

    // UI Elements
    const callButton = document.getElementById('callButton');
    const callIcon = document.getElementById('callIcon');
    const callText = document.getElementById('callText');
    const statusDot = document.getElementById('statusDot');
    const statusText = document.getElementById('statusText');
    const conversation = document.getElementById('conversation');
    const debugInfo = document.getElementById('debugInfo');
    const debugToggle = document.getElementById('debugToggle');
    const debugModal = document.getElementById('debugModal');
    const debugClose = document.getElementById('debugClose');
    const debugPreview = document.getElementById('debugPreview');
    const debugPreviewContent = document.getElementById('debugPreviewContent');
    const debugBadge = document.getElementById('debugBadge');
    const debugExpandBtn = document.getElementById('debugExpandBtn');

    // State
    let session = null;
    let isConnected = false;
    let audioStream = null;
    let transcriptMap = new Map(); // Track messages by speaker-specific IDs
    let logHistory = [];
    let errorCount = 0;
    let currentSessionId = null;
    let callStartTime = null;

    // Call Logging System with localStorage persistence
    function saveLogToStorage(logEntry) {
      try {
        // Get existing logs
        const storedLogs = localStorage.getItem('talkaflow_call_logs');
        let logs = storedLogs ? JSON.parse(storedLogs) : [];

        // Add new log entry
        logs.push(logEntry);

        // Keep only last 500 log entries to prevent storage overflow
        if (logs.length > 500) {
          logs = logs.slice(-500);
        }

        // Save back to localStorage
        localStorage.setItem('talkaflow_call_logs', JSON.stringify(logs));
      } catch (error) {
        console.error('Failed to save log to storage:', error);
      }
    }

    function getStoredLogs() {
      try {
        const storedLogs = localStorage.getItem('talkaflow_call_logs');
        return storedLogs ? JSON.parse(storedLogs) : [];
      } catch (error) {
        console.error('Failed to read logs from storage:', error);
        return [];
      }
    }

    function clearStoredLogs() {
      try {
        localStorage.removeItem('talkaflow_call_logs');
        console.log('All call logs cleared from storage');
      } catch (error) {
        console.error('Failed to clear logs:', error);
      }
    }

    function downloadLogs() {
      try {
        const logs = getStoredLogs();
        const logText = logs.map(entry => {
          return `[${entry.fullTimestamp}] [Session: ${entry.sessionId || 'N/A'}] [${entry.type.toUpperCase()}] ${entry.message}`;
        }).join('\n');

        const blob = new Blob([logText], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `talkaflow_logs_${new Date().toISOString().replace(/:/g, '-')}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        log('Logs downloaded successfully', 'success');
      } catch (error) {
        log(`Failed to download logs: ${error.message}`, 'error');
      }
    }

    // Logging
    function log(message, type = 'info') {
      const now = new Date();
      const timestamp = now.toLocaleTimeString();
      const fullTimestamp = now.toISOString();
      const icon = type === 'error' ? '❌' : type === 'success' ? '✅' : 'ℹ️';

      const div = document.createElement('div');
      div.className = `mb-1 ${type === 'error' ? 'text-red-600' : type === 'success' ? 'text-green-600' : 'text-gray-600'}`;
      div.innerHTML = `<span class="text-gray-400">[${timestamp}]</span> ${icon} ${message}`;

      debugInfo.appendChild(div);
      debugInfo.scrollTop = debugInfo.scrollHeight;
      console.log(`[${timestamp}] ${message}`);

      // Create log entry for storage
      const logEntry = {
        timestamp,
        fullTimestamp,
        message,
        type,
        icon,
        sessionId: currentSessionId,
        agentType: agentType,
        browser: navigator.userAgent,
        online: navigator.onLine
      };

      // Track in history
      logHistory.push(logEntry);
      if (logHistory.length > 50) logHistory.shift(); // Keep last 50 logs in memory

      // Save to localStorage
      saveLogToStorage(logEntry);

      // Update error count
      if (type === 'error') {
        errorCount++;
        debugBadge.textContent = errorCount;
        debugBadge.classList.remove('hidden');

        // Auto-show preview on errors
        setTimeout(() => {
          debugPreview.classList.remove('hidden');
        }, 100);
      }

      // Update preview with last 5 logs
      updateDebugPreview();
    }

    // Update debug preview panel
    function updateDebugPreview() {
      const recentLogs = logHistory.slice(-5);
      debugPreviewContent.innerHTML = recentLogs.map(entry => {
        const color = entry.type === 'error' ? 'text-red-600' : entry.type === 'success' ? 'text-green-600' : 'text-gray-600';
        return `<div class="${color}">${entry.icon} ${entry.message.substring(0, 60)}${entry.message.length > 60 ? '...' : ''}</div>`;
      }).join('');
    }

    // Update status
    function updateStatus(status) {
      const statuses = {
        'disconnected': { color: 'bg-gray-400', text: 'Disconnected' },
        'connecting': { color: 'animate-pulse', customColor: '#116dff', text: 'Connecting...' },
        'connected': { color: '', customColor: '#008250', text: 'Connected' },
        'listening': { color: 'animate-pulse', customColor: '#116dff', text: 'Listening' },
        'speaking': { color: '', customColor: '#df3131', text: 'AI Speaking' }
      };

      const s = statuses[status] || statuses.disconnected;
      statusDot.className = `w-3 h-3 rounded-full ${s.color}`;
      if (s.customColor) {
        statusDot.style.backgroundColor = s.customColor;
      } else {
        statusDot.style.backgroundColor = '';
      }
      statusText.textContent = s.text;

      isConnected = status !== 'disconnected';
      updateCallButton();
    }

    // Update call button
    function updateCallButton() {
      if (isConnected) {
        callButton.className = 'disabled:bg-gray-400 text-white px-12 py-6 rounded-xl font-bold text-xl transition-all transform hover:scale-105 shadow-lg disabled:cursor-not-allowed disabled:transform-none';
        callButton.style.backgroundColor = '#df3131';
        callButton.dataset.connected = 'true';
        callButton.onmouseover = function() { if(!this.disabled) this.style.backgroundColor='#b92828'; };
        callButton.onmouseout = function() { if(!this.disabled) this.style.backgroundColor='#df3131'; };
        callIcon.className = 'fas fa-phone-slash mr-3';
        callText.textContent = 'End Call';
        callButton.disabled = false;
      } else {
        callButton.className = 'disabled:bg-gray-400 text-white px-12 py-6 rounded-xl font-bold text-xl transition-all transform hover:scale-105 shadow-lg disabled:cursor-not-allowed disabled:transform-none';
        callButton.style.backgroundColor = '#008250';
        callButton.dataset.connected = 'false';
        callButton.onmouseover = function() { if(!this.disabled) this.style.backgroundColor='#006b43'; };
        callButton.onmouseout = function() { if(!this.disabled) this.style.backgroundColor='#008250'; };
        callIcon.className = 'fas fa-phone mr-3';
        callText.textContent = 'Start Voice Call';
        callButton.disabled = typeof UltravoxSession === 'undefined' || !agentConfig;
      }
    }

    // Track current speaker's message element
    let currentMessageElement = null;
    let currentSpeaker = null;

    // Add or update message to conversation
    function addOrUpdateMessage(speaker, text, isFinal = false) {
      if (conversation.children.length === 1 && conversation.children[0].querySelector('.fa-microphone')) {
        conversation.innerHTML = '';
      }

      // If different speaker, create new message bubble
      if (speaker !== currentSpeaker) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `flex items-start space-x-3 p-4 rounded-lg ${
          speaker === 'user'
            ? 'border-l-4 ml-4'
            : 'bg-white border-l-4 border-gray-300 mr-4 shadow-sm dark-mode-message-agent'
        }`;

        if (speaker === 'user') {
          messageDiv.style.backgroundColor = 'rgba(17, 109, 255, 0.1)';
          messageDiv.style.borderColor = '#116dff';
        }

        messageDiv.innerHTML = `
          <div class="flex-shrink-0">
            ${speaker === 'user'
              ? `<div class="w-8 h-8 rounded-full flex items-center justify-center text-white" style="background-color: #116dff;">
                  <i class="fas fa-user text-sm"></i>
                </div>`
              : `<img src="talkaFlow_logo_only.png" alt="TalkaFlow" class="w-8 h-8 rounded-full object-cover" onerror="this.style.display='none';this.nextElementSibling.style.display='flex';" />
                 <div class="w-8 h-8 rounded-full bg-gray-600 text-white items-center justify-center" style="display:none;">
                  <i class="fas fa-robot text-sm"></i>
                </div>`
            }
          </div>
          <div class="flex-1">
            <div class="font-medium text-sm mb-1 ${speaker === 'user' ? '' : 'dark-mode-text'}" style="color: ${speaker === 'user' ? '#116dff' : '#212121'}">
              ${speaker === 'user' ? 'You' : (agentConfig ? agentConfig.name : 'AI Assistant')}
            </div>
            <p class="text-gray-700 dark-mode-text-secondary message-text">${text}</p>
          </div>
        `;

        conversation.appendChild(messageDiv);
        currentMessageElement = messageDiv.querySelector('.message-text');
        currentSpeaker = speaker;
      } else {
        // Same speaker, update existing bubble in real-time
        if (currentMessageElement) {
          currentMessageElement.textContent = text;
        }
      }

      // If final, reset tracking so next message creates new bubble
      if (isFinal) {
        currentMessageElement = null;
        currentSpeaker = null;
      }

      conversation.scrollTop = conversation.scrollHeight;
    }

    // Legacy function for static messages
    function addMessage(speaker, text) {
      addOrUpdateMessage(speaker, text, true);
    }

    // Create call
    async function createCall() {
      try {
        log(`Making API request via proxy: /api/ultravox`);

        const response = await fetch('/api/ultravox', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ agentId: agentConfig.id })
        });

        log(`Response status: ${response.status}`);

        if (!response.ok) {
          const errorData = await response.json();
          log(`API error response: ${JSON.stringify(errorData)}`, 'error');
          throw new Error(`API Error ${response.status}: ${errorData.error || 'Unknown error'}`);
        }

        const data = await response.json();
        log(`Call created successfully: ${data.callId}`, 'success');
        return data;
      } catch (error) {
        log(`Fetch error: ${error.message}`, 'error');
        if (error.message.includes('Failed to fetch')) {
          throw new Error('Network error: Unable to connect to API proxy.');
        }
        throw error;
      }
    }

    // Start call
    async function startCall() {
      try {
        // Generate unique session ID for this call
        currentSessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        callStartTime = new Date();

        log('=== NEW CALL SESSION STARTED ===', 'info');
        log(`Session ID: ${currentSessionId}`, 'info');
        log(`Agent: ${agentConfig.name} (${agentConfig.id})`, 'info');
        log('Starting voice call...');
        updateStatus('connecting');

        if (typeof UltravoxSession === 'undefined') {
          throw new Error('Voice SDK not loaded. Please refresh the page.');
        }

        if (!agentConfig) {
          throw new Error('Agent configuration not loaded. Please refresh the page.');
        }

        // Create call
        const callData = await createCall();
        log(`Call created: ${callData.callId}`, 'success');

        // Initialize session
        session = new UltravoxSession();

        // Setup listeners
        session.addEventListener('status', () => {
          const previousStatus = session.status;
          updateStatus(session.status);
          log(`Status changed: ${previousStatus} → ${session.status}`);
        });

        session.addEventListener('transcripts', () => {
          const transcripts = session.transcripts;
          if (transcripts && transcripts.length > 0) {
            const latest = transcripts[transcripts.length - 1];

            // Only log final transcripts to reduce debug noise
            if (latest.isFinal) {
              log(`Transcript: [${latest.speaker}] "${latest.text}" (final: ${latest.isFinal})`);
            }

            // Determine speaker
            const speaker = latest.speaker === 'user' ? 'user' : 'agent';

            // Show all transcripts in real-time (both interim and final)
            addOrUpdateMessage(speaker, latest.text, latest.isFinal);
          }
        });

        // Add error and disconnect listeners for diagnostics
        session.addEventListener('error', (event) => {
          log(`⚠️ Session error: ${JSON.stringify(event)}`, 'error');
          console.error('Ultravox session error:', event);
        });

        session.addEventListener('disconnect', (event) => {
          const disconnectTime = new Date();
          log('=== CALL DISCONNECTED ===', 'error');
          log(`Disconnect time: ${disconnectTime.toISOString()}`, 'error');
          log(`Session ID: ${currentSessionId}`, 'error');

          // Log call duration
          if (callStartTime) {
            const callDuration = Math.floor((disconnectTime - callStartTime) / 1000);
            log(`Total call duration: ${callDuration} seconds`, 'error');
          }

          // Log disconnect event details
          if (event && event.detail) {
            log(`Disconnect reason: ${JSON.stringify(event.detail)}`, 'error');
          } else if (event) {
            log(`Disconnect event: ${JSON.stringify(event)}`, 'error');
          }

          // Log network status at disconnect
          log(`Network online: ${navigator.onLine}`, 'error');
          log(`Connection type: ${navigator.connection?.effectiveType || 'Unknown'}`, 'error');

          console.warn('Ultravox session disconnected:', event);
          updateStatus('disconnected');

          // Provide specific feedback based on when disconnect happened
          if (isConnected) {
            const wasShort = callStartTime && (Date.now() - callStartTime < 10000);
            if (wasShort) {
              addMessage('agent', '⚠️ Call ended shortly after greeting. This may be due to: (1) No microphone input detected, (2) Agent timeout, or (3) Network issue. Please ensure your microphone is working and try again.');
              log('⚠️ Short call detected - likely microphone or agent timeout issue', 'error');
            } else {
              addMessage('agent', '⚠️ Call disconnected unexpectedly. Please check your internet connection and microphone permissions.');
            }
          }
        });

        // Monitor connection quality
        let lastActivityTime = Date.now();
        const activityMonitor = setInterval(() => {
          if (session && isConnected) {
            const timeSinceActivity = Date.now() - lastActivityTime;
            if (timeSinceActivity > 30000) { // 30 seconds of silence
              log(`⚠️ No activity for ${Math.floor(timeSinceActivity / 1000)}s`, 'error');
            }
          } else {
            clearInterval(activityMonitor);
          }
        }, 10000); // Check every 10 seconds

        // Track activity
        session.addEventListener('transcripts', () => {
          lastActivityTime = Date.now();
        });

        // Request microphone permission explicitly before joining
        log('Requesting microphone permission...');
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          log('✅ Microphone permission granted', 'success');

          // Test if we're getting audio input (wait for mic to warm up)
          const audioContext = new AudioContext();
          const source = audioContext.createMediaStreamSource(stream);
          const analyser = audioContext.createAnalyser();
          source.connect(analyser);

          // Wait 200ms for microphone to start capturing audio
          await new Promise(resolve => setTimeout(resolve, 200));

          const dataArray = new Uint8Array(analyser.frequencyBinCount);
          analyser.getByteFrequencyData(dataArray);
          const average = dataArray.reduce((a, b) => a + b) / dataArray.length;

          if (average > 0) {
            log(`✅ Microphone is active (level: ${Math.floor(average)})`, 'success');
          } else {
            log('ℹ️ Microphone ready (background noise level: low)', 'info');
          }

          audioStream = stream;
        } catch (micError) {
          log(`❌ Microphone permission denied: ${micError.message}`, 'error');
          throw new Error('Microphone access required for voice calls. Please allow microphone access and try again.');
        }

        // Join call
        log('Joining call with Ultravox...');
        await session.joinCall(callData.joinUrl);
        log('✅ Voice call connected!', 'success');
        lastActivityTime = Date.now();

      } catch (error) {
        log('=== CALL FAILED TO START ===', 'error');
        log(`Error: ${error.message}`, 'error');
        log(`Error stack: ${error.stack}`, 'error');
        log(`Session ID: ${currentSessionId}`, 'error');
        updateStatus('disconnected');

        // Clear session tracking on failure
        currentSessionId = null;
        callStartTime = null;

        alert(`Failed to start call: ${error.message}`);
      }
    }

    // End call
    async function endCall() {
      try {
        log('=== USER ENDED CALL ===', 'info');
        log('Ending call...');

        // Log call duration
        if (callStartTime) {
          const endTime = new Date();
          const callDuration = Math.floor((endTime - callStartTime) / 1000);
          log(`Call duration: ${callDuration} seconds`, 'info');
        }

        if (session) {
          await session.leaveCall();
          session = null;
        }

        if (audioStream) {
          audioStream.getTracks().forEach(track => track.stop());
          audioStream = null;
        }

        updateStatus('disconnected');
        log(`Call ended successfully`, 'success');
        log(`Session ID: ${currentSessionId}`, 'info');

        addMessage('agent', `Thank you for contacting ${agentConfig.name}. Have a wonderful day!`);

        // Clear session ID
        currentSessionId = null;
        callStartTime = null;

      } catch (error) {
        log(`Error ending call: ${error.message}`, 'error');
        updateStatus('disconnected');
      }
    }

    // Call button handler
    callButton.addEventListener('click', () => {
      if (isConnected) {
        endCall();
      } else {
        startCall();
      }
    });

    // Debug preview toggle
    let previewVisible = false;
    debugToggle.addEventListener('click', () => {
      previewVisible = !previewVisible;
      if (previewVisible) {
        debugPreview.classList.remove('hidden');
      } else {
        debugPreview.classList.add('hidden');
      }
    });

    // Debug expand button - opens full modal
    debugExpandBtn.addEventListener('click', () => {
      debugPreview.classList.add('hidden');
      previewVisible = false;
      debugModal.classList.remove('hidden');
      debugModal.classList.add('flex');
    });

    // Debug modal close
    debugClose.addEventListener('click', () => {
      debugModal.classList.add('hidden');
      debugModal.classList.remove('flex');
    });

    // Close modal when clicking outside
    debugModal.addEventListener('click', (e) => {
      if (e.target === debugModal) {
        debugModal.classList.add('hidden');
        debugModal.classList.remove('flex');
      }
    });

    // Download logs button
    const downloadLogsBtn = document.getElementById('downloadLogsBtn');
    downloadLogsBtn.addEventListener('click', () => {
      downloadLogs();
    });

    // Clear logs button
    const clearLogsBtn = document.getElementById('clearLogsBtn');
    clearLogsBtn.addEventListener('click', () => {
      if (confirm('Are you sure you want to clear all saved call logs? This cannot be undone.')) {
        clearStoredLogs();
        log('All logs cleared from storage', 'success');
      }
    });

    // Monitor network connectivity
    window.addEventListener('online', () => {
      log('✅ Network connection restored', 'success');
    });

    window.addEventListener('offline', () => {
      log('❌ Network connection lost!', 'error');
      if (session && isConnected) {
        alert('Network connection lost. The call may disconnect.');
      }
    });

    // Auto-cleanup when page is closed or navigated away
    window.addEventListener('beforeunload', (event) => {
      if (session && isConnected) {
        log('Page closing - ending call automatically');
        // End call immediately without waiting
        if (session) {
          try {
            session.leaveCall();
          } catch (e) {
            console.error('Error leaving call:', e);
          }
        }
        if (audioStream) {
          audioStream.getTracks().forEach(track => track.stop());
        }
      }
    });

    // Note: Removed visibility change listener to allow tab switching during calls
    // Calls will only end when the page is actually closed (beforeunload/pagehide)

    // Handle page unload (when navigating to another page)
    window.addEventListener('pagehide', () => {
      if (session && isConnected) {
        log('Page unloading - ending call');
        if (session) {
          try {
            session.leaveCall();
          } catch (e) {
            console.error('Error leaving call:', e);
          }
        }
      }
    });

    // Dark Mode Toggle
    const darkModeToggle = document.getElementById('darkModeToggle');
    const darkModeIcon = document.getElementById('darkModeIcon');

    // Check for saved dark mode preference
    const isDarkMode = localStorage.getItem('darkMode') === 'true';
    if (isDarkMode) {
      document.body.classList.add('dark-mode');
      darkModeIcon.className = 'fas fa-sun text-lg';
    }

    // Toggle dark mode
    darkModeToggle.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      const isDark = document.body.classList.contains('dark-mode');

      // Update icon
      darkModeIcon.className = isDark ? 'fas fa-sun text-lg' : 'fas fa-moon text-lg';

      // Save preference
      localStorage.setItem('darkMode', isDark);

      log(`Dark mode ${isDark ? 'enabled' : 'disabled'}`);
    });

    // Initialize
    document.addEventListener('DOMContentLoaded', async () => {
      log('TalkaFlow Voice AI Interface loaded');

      // Log system information for diagnostics
      log(`Browser: ${navigator.userAgent}`);
      log(`Online: ${navigator.onLine ? 'Yes' : 'No'}`);
      log(`Connection: ${navigator.connection?.effectiveType || 'Unknown'}`);
      log(`Agent Type: ${agentType}`);

      // Log stored logs information
      const storedLogs = getStoredLogs();
      log(`Stored logs: ${storedLogs.length} entries in localStorage`);
      if (storedLogs.length > 0) {
        const oldestLog = storedLogs[0];
        const newestLog = storedLogs[storedLogs.length - 1];
        log(`Oldest log: ${oldestLog.fullTimestamp}`);
        log(`Newest log: ${newestLog.fullTimestamp}`);
      }

      updateStatus('disconnected');

      // Load SDK
      log('Loading voice processing SDK...');
      try {
        const loaded = await window.loadSDK();
        if (loaded) {
          log('Voice SDK loaded successfully!', 'success');
          updateCallButton();
        } else {
          log('Failed to load voice SDK', 'error');
          callButton.disabled = true;
          callText.textContent = 'Voice SDK Unavailable';
        }
      } catch (error) {
        log(`SDK error: ${error.message}`, 'error');
        callButton.disabled = true;
      }
    });
  </script>
</body>
</html>
