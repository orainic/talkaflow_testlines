<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title id="pageTitle">TalkaFlow Voice AI</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="icon" type="image/png" href="/talkaFlow_logo_only.png">
  <!-- Load SDK from multiple sources -->
  <script>
    window.loadSDK = async function() {
      const sources = [
        'https://cdn.skypack.dev/ultravox-client@0.4.1',
        'https://unpkg.com/ultravox-client@0.4.1?module',
        'https://esm.run/ultravox-client@0.4.1',
        'https://cdn.jsdelivr.net/npm/ultravox-client@0.4.1/+esm'
      ];

      for (const src of sources) {
        try {
          const module = await import(src);
          if (module.UltravoxSession) {
            window.UltravoxSession = module.UltravoxSession;
            console.log('✅ SDK loaded from:', src);
            return true;
          }
        } catch (e) {
          console.log('❌ Failed:', src, e.message);
        }
      }
      return false;
    };
  </script>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen">
  <!-- Header with Logo -->
  <div class="bg-white shadow-sm border-b">
    <div class="max-w-4xl mx-auto px-4 py-4">
      <div class="flex items-center justify-between">
        <div class="flex items-center space-x-3">
          <a href="https://www.talkaflow.com" target="_blank" rel="noopener noreferrer">
            <img src="/talkaFlow_logo_only.png" alt="TalkaFlow" class="w-10 h-10 hover:opacity-80 transition-opacity cursor-pointer" />
          </a>
          <div>
            <h1 id="agentName" class="text-xl font-bold text-gray-900">TalkaFlow Voice AI</h1>
            <p id="agentTitle" class="text-sm text-gray-600">AI Voice Assistant</p>
          </div>
        </div>
        <div class="flex items-center space-x-4">
          <div id="connectionStatus" class="flex items-center space-x-2">
            <div id="statusDot" class="w-3 h-3 rounded-full bg-gray-400"></div>
            <span id="statusText" class="text-sm font-medium text-gray-600">Disconnected</span>
          </div>
          <a href="https://www.talkaflow.com" target="_blank" rel="noopener noreferrer"
             class="w-9 h-9 rounded-full flex items-center justify-center transition-all hover:scale-110"
             style="background-color: rgba(17, 109, 255, 0.1);"
             onmouseover="this.style.backgroundColor='rgba(17, 109, 255, 0.2)'"
             onmouseout="this.style.backgroundColor='rgba(17, 109, 255, 0.1)'"
             title="Return to TalkaFlow Home">
            <i class="fas fa-home" style="color: #116dff;"></i>
          </a>
        </div>
      </div>
    </div>
  </div>

  <div class="max-w-4xl mx-auto px-4 py-8">
    <!-- Main Call Interface -->
    <div class="bg-white rounded-xl shadow-lg p-8 mb-6">
      <div class="text-center mb-8">
        <div class="inline-flex items-center justify-center w-16 h-16 rounded-full mb-4" style="background-color: #116dff;">
          <i id="agentIcon" class="fas fa-microphone text-white text-2xl"></i>
        </div>
        <h2 id="agentDescription" class="text-2xl font-bold text-gray-900 mb-4">AI Voice Assistant</h2>

        <!-- Call Button -->
        <div class="space-y-4">
          <button id="callButton"
                  class="disabled:bg-gray-400 text-white px-12 py-6 rounded-xl font-bold text-xl transition-all transform hover:scale-105 shadow-lg disabled:cursor-not-allowed disabled:transform-none"
                  style="background-color: #008250;"
                  onmouseover="if(!this.disabled) this.style.backgroundColor='#006b43'"
                  onmouseout="if(!this.disabled && !this.dataset.connected) this.style.backgroundColor='#008250'; else if(!this.disabled && this.dataset.connected) this.style.backgroundColor='#df3131'">
            <i id="callIcon" class="fas fa-phone mr-3"></i>
            <span id="callText">Start Voice Call</span>
          </button>

          <p class="text-sm text-gray-600">
            Click to connect with the AI assistant
          </p>
        </div>
      </div>

      <!-- What You Can Ask -->
      <div id="suggestionsContainer" class="rounded-lg p-6 mb-6" style="background-color: rgba(17, 109, 255, 0.08);">
        <h3 class="font-semibold mb-3" style="color: #116dff;">
          <i class="fas fa-question-circle mr-2"></i>
          What you can ask:
        </h3>
        <div id="suggestionsList" class="grid grid-cols-1 md:grid-cols-2 gap-3 text-sm" style="color: #116dff;">
          <!-- Dynamically populated -->
        </div>
      </div>

      <!-- Conversation Area -->
      <div class="bg-gray-50 rounded-lg p-6">
        <h3 class="font-semibold text-gray-900 mb-4 flex items-center">
          <i class="fas fa-comments mr-2"></i>
          Conversation
        </h3>
        <div id="conversation" class="space-y-3 max-h-96 overflow-y-auto">
          <div class="text-center text-gray-500 py-8">
            <i class="fas fa-microphone text-4xl mb-3 opacity-30"></i>
            <p>Start a call to begin speaking with the AI assistant</p>
          </div>
        </div>
      </div>
    </div>

    <!-- Debug Panel - Small Icon with Preview -->
    <div class="fixed bottom-4 right-4 z-40">
      <!-- Compact Preview (collapsed state) -->
      <div id="debugPreview" class="bg-white rounded-lg shadow-xl mb-2 p-3 max-w-xs hidden">
        <div class="flex items-center justify-between mb-2">
          <h4 class="text-xs font-semibold text-gray-700">Recent Logs</h4>
          <button id="debugExpandBtn" class="text-xs" style="color: #116dff;" onmouseover="this.style.color='#0d5cd6'" onmouseout="this.style.color='#116dff'">
            <i class="fas fa-expand-alt"></i>
          </button>
        </div>
        <div id="debugPreviewContent" class="text-xs font-mono text-gray-600 max-h-32 overflow-y-auto space-y-1">
          <p>Loading...</p>
        </div>
      </div>

      <!-- Toggle Button -->
      <button id="debugToggle" class="text-white w-12 h-12 rounded-full shadow-lg flex items-center justify-center transition-all relative" style="background-color: #116dff;" onmouseover="this.style.backgroundColor='#0d5cd6'" onmouseout="this.style.backgroundColor='#116dff'" title="Debug Logs">
        <i class="fas fa-bug text-lg"></i>
        <span id="debugBadge" class="absolute -top-1 -right-1 text-white text-xs w-5 h-5 rounded-full hidden items-center justify-center font-bold" style="background-color: #df3131;">0</span>
      </button>
    </div>

    <!-- Debug Panel Modal (Hidden by default) -->
    <div id="debugModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
      <div class="bg-white rounded-lg shadow-xl max-w-2xl w-full mx-4 max-h-96 flex flex-col">
        <div class="flex items-center justify-between p-4 border-b">
          <h3 class="font-medium text-gray-900 flex items-center">
            <i class="fas fa-cog mr-2"></i>
            Technical Information
          </h3>
          <button id="debugClose" class="text-gray-400 hover:text-gray-600">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div id="debugInfo" class="p-4 text-xs font-mono text-gray-600 overflow-y-auto flex-1">
          <p>Loading system...</p>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Load agent configuration
    let agentConfig = null;
    let agentsData = null;

    // Parse URL to get agent type - check both path and query param
    function getAgentType() {
      // First check query parameter
      const urlParams = new URLSearchParams(window.location.search);
      const queryAgent = urlParams.get('agent');
      if (queryAgent) return queryAgent;

      // Then check path (e.g., /hotel, /clinic)
      const path = window.location.pathname;
      const pathMatch = path.match(/\/(hotel|clinic|aftersales|restaurant|hairstudio|hepa|dental)/);
      if (pathMatch) return pathMatch[1];

      // Default to hotel
      return 'hotel';
    }

    const agentType = getAgentType();

    // Load agents config
    fetch('/agents-config.json')
      .then(res => res.json())
      .then(data => {
        agentsData = data;
        agentConfig = data[agentType];

        if (!agentConfig) {
          console.error('Unknown agent type:', agentType);
          agentConfig = data.hotel; // Fallback to hotel
        }

        // Update page with agent info
        updateAgentInfo();

        // Enable button if SDK is already loaded
        updateCallButton();
      })
      .catch(err => {
        console.error('Failed to load agent config:', err);
      });

    function updateAgentInfo() {
      if (!agentConfig) return;

      // Update page title and meta
      document.title = `${agentConfig.name} - TalkaFlow Voice AI`;
      document.getElementById('pageTitle').textContent = `${agentConfig.name} - TalkaFlow`;
      document.getElementById('agentName').textContent = agentConfig.name;
      document.getElementById('agentTitle').textContent = agentConfig.title;
      document.getElementById('agentDescription').textContent = agentConfig.description;
      document.getElementById('agentIcon').className = `fas ${agentConfig.icon} text-white text-2xl`;

      // Update suggestions
      const suggestionsList = document.getElementById('suggestionsList');
      suggestionsList.innerHTML = '';
      agentConfig.suggestions.forEach(suggestion => {
        const div = document.createElement('div');
        div.className = 'flex items-start';
        div.innerHTML = `
          <i class="fas fa-comment-dots mr-2 mt-1 flex-shrink-0" style="color: #116dff;"></i>
          <span>"${suggestion}"</span>
        `;
        suggestionsList.appendChild(div);
      });

      log(`Agent loaded: ${agentConfig.name} (${agentConfig.id})`);
    }

    // UI Elements
    const callButton = document.getElementById('callButton');
    const callIcon = document.getElementById('callIcon');
    const callText = document.getElementById('callText');
    const statusDot = document.getElementById('statusDot');
    const statusText = document.getElementById('statusText');
    const conversation = document.getElementById('conversation');
    const debugInfo = document.getElementById('debugInfo');
    const debugToggle = document.getElementById('debugToggle');
    const debugModal = document.getElementById('debugModal');
    const debugClose = document.getElementById('debugClose');
    const debugPreview = document.getElementById('debugPreview');
    const debugPreviewContent = document.getElementById('debugPreviewContent');
    const debugBadge = document.getElementById('debugBadge');
    const debugExpandBtn = document.getElementById('debugExpandBtn');

    // State
    let session = null;
    let isConnected = false;
    let audioStream = null;
    let transcriptMap = new Map(); // Track messages by speaker-specific IDs
    let logHistory = [];
    let errorCount = 0;

    // Logging
    function log(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const icon = type === 'error' ? '❌' : type === 'success' ? '✅' : 'ℹ️';

      const div = document.createElement('div');
      div.className = `mb-1 ${type === 'error' ? 'text-red-600' : type === 'success' ? 'text-green-600' : 'text-gray-600'}`;
      div.innerHTML = `<span class="text-gray-400">[${timestamp}]</span> ${icon} ${message}`;

      debugInfo.appendChild(div);
      debugInfo.scrollTop = debugInfo.scrollHeight;
      console.log(`[${timestamp}] ${message}`);

      // Track in history
      logHistory.push({ timestamp, message, type, icon });
      if (logHistory.length > 50) logHistory.shift(); // Keep last 50 logs

      // Update error count
      if (type === 'error') {
        errorCount++;
        debugBadge.textContent = errorCount;
        debugBadge.classList.remove('hidden');

        // Auto-show preview on errors
        setTimeout(() => {
          debugPreview.classList.remove('hidden');
        }, 100);
      }

      // Update preview with last 5 logs
      updateDebugPreview();
    }

    // Update debug preview panel
    function updateDebugPreview() {
      const recentLogs = logHistory.slice(-5);
      debugPreviewContent.innerHTML = recentLogs.map(entry => {
        const color = entry.type === 'error' ? 'text-red-600' : entry.type === 'success' ? 'text-green-600' : 'text-gray-600';
        return `<div class="${color}">${entry.icon} ${entry.message.substring(0, 60)}${entry.message.length > 60 ? '...' : ''}</div>`;
      }).join('');
    }

    // Update status
    function updateStatus(status) {
      const statuses = {
        'disconnected': { color: 'bg-gray-400', text: 'Disconnected' },
        'connecting': { color: 'animate-pulse', customColor: '#116dff', text: 'Connecting...' },
        'connected': { color: '', customColor: '#008250', text: 'Connected' },
        'listening': { color: 'animate-pulse', customColor: '#116dff', text: 'Listening' },
        'speaking': { color: '', customColor: '#df3131', text: 'AI Speaking' }
      };

      const s = statuses[status] || statuses.disconnected;
      statusDot.className = `w-3 h-3 rounded-full ${s.color}`;
      if (s.customColor) {
        statusDot.style.backgroundColor = s.customColor;
      } else {
        statusDot.style.backgroundColor = '';
      }
      statusText.textContent = s.text;

      isConnected = status !== 'disconnected';
      updateCallButton();
    }

    // Update call button
    function updateCallButton() {
      if (isConnected) {
        callButton.className = 'disabled:bg-gray-400 text-white px-12 py-6 rounded-xl font-bold text-xl transition-all transform hover:scale-105 shadow-lg disabled:cursor-not-allowed disabled:transform-none';
        callButton.style.backgroundColor = '#df3131';
        callButton.dataset.connected = 'true';
        callButton.onmouseover = function() { if(!this.disabled) this.style.backgroundColor='#b92828'; };
        callButton.onmouseout = function() { if(!this.disabled) this.style.backgroundColor='#df3131'; };
        callIcon.className = 'fas fa-phone-slash mr-3';
        callText.textContent = 'End Call';
        callButton.disabled = false;
      } else {
        callButton.className = 'disabled:bg-gray-400 text-white px-12 py-6 rounded-xl font-bold text-xl transition-all transform hover:scale-105 shadow-lg disabled:cursor-not-allowed disabled:transform-none';
        callButton.style.backgroundColor = '#008250';
        callButton.dataset.connected = 'false';
        callButton.onmouseover = function() { if(!this.disabled) this.style.backgroundColor='#006b43'; };
        callButton.onmouseout = function() { if(!this.disabled) this.style.backgroundColor='#008250'; };
        callIcon.className = 'fas fa-phone mr-3';
        callText.textContent = 'Start Voice Call';
        callButton.disabled = typeof UltravoxSession === 'undefined' || !agentConfig;
      }
    }

    // Track current speaker's message element
    let currentMessageElement = null;
    let currentSpeaker = null;

    // Add or update message to conversation
    function addOrUpdateMessage(speaker, text, isFinal = false) {
      if (conversation.children.length === 1 && conversation.children[0].querySelector('.fa-microphone')) {
        conversation.innerHTML = '';
      }

      // If different speaker, create new message bubble
      if (speaker !== currentSpeaker) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `flex items-start space-x-3 p-4 rounded-lg ${
          speaker === 'user'
            ? 'border-l-4 ml-4'
            : 'bg-white border-l-4 border-gray-300 mr-4 shadow-sm'
        }`;

        if (speaker === 'user') {
          messageDiv.style.backgroundColor = 'rgba(17, 109, 255, 0.1)';
          messageDiv.style.borderColor = '#116dff';
        }

        messageDiv.innerHTML = `
          <div class="flex-shrink-0">
            ${speaker === 'user'
              ? `<div class="w-8 h-8 rounded-full flex items-center justify-center text-white" style="background-color: #116dff;">
                  <i class="fas fa-user text-sm"></i>
                </div>`
              : `<img src="talkaFlow_logo_only.png" alt="TalkaFlow" class="w-8 h-8 rounded-full object-cover" onerror="this.style.display='none';this.nextElementSibling.style.display='flex';" />
                 <div class="w-8 h-8 rounded-full bg-gray-600 text-white items-center justify-center" style="display:none;">
                  <i class="fas fa-robot text-sm"></i>
                </div>`
            }
          </div>
          <div class="flex-1">
            <div class="font-medium text-sm mb-1" style="color: ${speaker === 'user' ? '#116dff' : '#212121'}">
              ${speaker === 'user' ? 'You' : (agentConfig ? agentConfig.name : 'AI Assistant')}
            </div>
            <p class="text-gray-700 message-text">${text}</p>
          </div>
        `;

        conversation.appendChild(messageDiv);
        currentMessageElement = messageDiv.querySelector('.message-text');
        currentSpeaker = speaker;
      } else {
        // Same speaker, update existing bubble in real-time
        if (currentMessageElement) {
          currentMessageElement.textContent = text;
        }
      }

      // If final, reset tracking so next message creates new bubble
      if (isFinal) {
        currentMessageElement = null;
        currentSpeaker = null;
      }

      conversation.scrollTop = conversation.scrollHeight;
    }

    // Legacy function for static messages
    function addMessage(speaker, text) {
      addOrUpdateMessage(speaker, text, true);
    }

    // Create call
    async function createCall() {
      try {
        log(`Making API request via proxy: /api/ultravox`);

        const response = await fetch('/api/ultravox', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ agentId: agentConfig.id })
        });

        log(`Response status: ${response.status}`);

        if (!response.ok) {
          const errorData = await response.json();
          log(`API error response: ${JSON.stringify(errorData)}`, 'error');
          throw new Error(`API Error ${response.status}: ${errorData.error || 'Unknown error'}`);
        }

        const data = await response.json();
        log(`Call created successfully: ${data.callId}`, 'success');
        return data;
      } catch (error) {
        log(`Fetch error: ${error.message}`, 'error');
        if (error.message.includes('Failed to fetch')) {
          throw new Error('Network error: Unable to connect to API proxy.');
        }
        throw error;
      }
    }

    // Start call
    async function startCall() {
      try {
        log('Starting voice call...');
        updateStatus('connecting');

        if (typeof UltravoxSession === 'undefined') {
          throw new Error('Voice SDK not loaded. Please refresh the page.');
        }

        if (!agentConfig) {
          throw new Error('Agent configuration not loaded. Please refresh the page.');
        }

        // Create call
        const callData = await createCall();
        log(`Call created: ${callData.callId}`, 'success');

        // Initialize session
        session = new UltravoxSession();

        // Setup listeners
        session.addEventListener('status', () => {
          const previousStatus = session.status;
          updateStatus(session.status);
          log(`Status changed: ${previousStatus} → ${session.status}`);
        });

        session.addEventListener('transcripts', () => {
          const transcripts = session.transcripts;
          if (transcripts && transcripts.length > 0) {
            const latest = transcripts[transcripts.length - 1];

            // Only log final transcripts to reduce debug noise
            if (latest.isFinal) {
              log(`Transcript: [${latest.speaker}] "${latest.text}" (final: ${latest.isFinal})`);
            }

            // Determine speaker
            const speaker = latest.speaker === 'user' ? 'user' : 'agent';

            // Show all transcripts in real-time (both interim and final)
            addOrUpdateMessage(speaker, latest.text, latest.isFinal);
          }
        });

        // Add error and disconnect listeners for diagnostics
        session.addEventListener('error', (event) => {
          log(`⚠️ Session error: ${JSON.stringify(event)}`, 'error');
          console.error('Ultravox session error:', event);
        });

        session.addEventListener('disconnect', (event) => {
          const disconnectTime = new Date().toLocaleTimeString();
          log(`🔌 Session disconnected at ${disconnectTime}`, 'error');
          log(`Disconnect details: ${JSON.stringify(event)}`, 'error');

          // Log call duration
          if (lastActivityTime) {
            const callDuration = Math.floor((Date.now() - lastActivityTime) / 1000);
            log(`Call duration: ${callDuration} seconds`, 'error');
          }

          console.warn('Ultravox session disconnected:', event);
          updateStatus('disconnected');

          // Provide specific feedback based on when disconnect happened
          if (isConnected) {
            const wasShort = lastActivityTime && (Date.now() - lastActivityTime < 10000);
            if (wasShort) {
              addMessage('agent', '⚠️ Call ended shortly after greeting. This may be due to: (1) No microphone input detected, (2) Agent timeout, or (3) Network issue. Please ensure your microphone is working and try again.');
              log('⚠️ Short call detected - likely microphone or agent timeout issue', 'error');
            } else {
              addMessage('agent', '⚠️ Call disconnected unexpectedly. Please check your internet connection and microphone permissions.');
            }
          }
        });

        // Monitor connection quality
        let lastActivityTime = Date.now();
        const activityMonitor = setInterval(() => {
          if (session && isConnected) {
            const timeSinceActivity = Date.now() - lastActivityTime;
            if (timeSinceActivity > 30000) { // 30 seconds of silence
              log(`⚠️ No activity for ${Math.floor(timeSinceActivity / 1000)}s`, 'error');
            }
          } else {
            clearInterval(activityMonitor);
          }
        }, 10000); // Check every 10 seconds

        // Track activity
        session.addEventListener('transcripts', () => {
          lastActivityTime = Date.now();
        });

        // Request microphone permission explicitly before joining
        log('Requesting microphone permission...');
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          log('✅ Microphone permission granted', 'success');

          // Test if we're getting audio input (wait for mic to warm up)
          const audioContext = new AudioContext();
          const source = audioContext.createMediaStreamSource(stream);
          const analyser = audioContext.createAnalyser();
          source.connect(analyser);

          // Wait 200ms for microphone to start capturing audio
          await new Promise(resolve => setTimeout(resolve, 200));

          const dataArray = new Uint8Array(analyser.frequencyBinCount);
          analyser.getByteFrequencyData(dataArray);
          const average = dataArray.reduce((a, b) => a + b) / dataArray.length;

          if (average > 0) {
            log(`✅ Microphone is active (level: ${Math.floor(average)})`, 'success');
          } else {
            log('ℹ️ Microphone ready (background noise level: low)', 'info');
          }

          audioStream = stream;
        } catch (micError) {
          log(`❌ Microphone permission denied: ${micError.message}`, 'error');
          throw new Error('Microphone access required for voice calls. Please allow microphone access and try again.');
        }

        // Join call
        log('Joining call with Ultravox...');
        await session.joinCall(callData.joinUrl);
        log('✅ Voice call connected!', 'success');
        lastActivityTime = Date.now();

      } catch (error) {
        log(`Call failed: ${error.message}`, 'error');
        updateStatus('disconnected');
        alert(`Failed to start call: ${error.message}`);
      }
    }

    // End call
    async function endCall() {
      try {
        log('Ending call...');

        if (session) {
          await session.leaveCall();
          session = null;
        }

        if (audioStream) {
          audioStream.getTracks().forEach(track => track.stop());
          audioStream = null;
        }

        updateStatus('disconnected');
        log('Call ended', 'success');

        addMessage('agent', `Thank you for contacting ${agentConfig.name}. Have a wonderful day!`);

      } catch (error) {
        log(`Error ending call: ${error.message}`, 'error');
        updateStatus('disconnected');
      }
    }

    // Call button handler
    callButton.addEventListener('click', () => {
      if (isConnected) {
        endCall();
      } else {
        startCall();
      }
    });

    // Debug preview toggle
    let previewVisible = false;
    debugToggle.addEventListener('click', () => {
      previewVisible = !previewVisible;
      if (previewVisible) {
        debugPreview.classList.remove('hidden');
      } else {
        debugPreview.classList.add('hidden');
      }
    });

    // Debug expand button - opens full modal
    debugExpandBtn.addEventListener('click', () => {
      debugPreview.classList.add('hidden');
      previewVisible = false;
      debugModal.classList.remove('hidden');
      debugModal.classList.add('flex');
    });

    // Debug modal close
    debugClose.addEventListener('click', () => {
      debugModal.classList.add('hidden');
      debugModal.classList.remove('flex');
    });

    // Close modal when clicking outside
    debugModal.addEventListener('click', (e) => {
      if (e.target === debugModal) {
        debugModal.classList.add('hidden');
        debugModal.classList.remove('flex');
      }
    });

    // Monitor network connectivity
    window.addEventListener('online', () => {
      log('✅ Network connection restored', 'success');
    });

    window.addEventListener('offline', () => {
      log('❌ Network connection lost!', 'error');
      if (session && isConnected) {
        alert('Network connection lost. The call may disconnect.');
      }
    });

    // Auto-cleanup when page is closed or navigated away
    window.addEventListener('beforeunload', (event) => {
      if (session && isConnected) {
        log('Page closing - ending call automatically');
        // End call immediately without waiting
        if (session) {
          try {
            session.leaveCall();
          } catch (e) {
            console.error('Error leaving call:', e);
          }
        }
        if (audioStream) {
          audioStream.getTracks().forEach(track => track.stop());
        }
      }
    });

    // Note: Removed visibility change listener to allow tab switching during calls
    // Calls will only end when the page is actually closed (beforeunload/pagehide)

    // Handle page unload (when navigating to another page)
    window.addEventListener('pagehide', () => {
      if (session && isConnected) {
        log('Page unloading - ending call');
        if (session) {
          try {
            session.leaveCall();
          } catch (e) {
            console.error('Error leaving call:', e);
          }
        }
      }
    });

    // Initialize
    document.addEventListener('DOMContentLoaded', async () => {
      log('TalkaFlow Voice AI Interface loaded');

      // Log system information for diagnostics
      log(`Browser: ${navigator.userAgent}`);
      log(`Online: ${navigator.onLine ? 'Yes' : 'No'}`);
      log(`Connection: ${navigator.connection?.effectiveType || 'Unknown'}`);
      log(`Agent Type: ${agentType}`);

      updateStatus('disconnected');

      // Load SDK
      log('Loading voice processing SDK...');
      try {
        const loaded = await window.loadSDK();
        if (loaded) {
          log('Voice SDK loaded successfully!', 'success');
          updateCallButton();
        } else {
          log('Failed to load voice SDK', 'error');
          callButton.disabled = true;
          callText.textContent = 'Voice SDK Unavailable';
        }
      } catch (error) {
        log(`SDK error: ${error.message}`, 'error');
        callButton.disabled = true;
      }
    });
  </script>
</body>
</html>
